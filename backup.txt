#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>
#include <vector>
#include <map>
#include <Eigen/Dense>
#include <algorithm>
#include <cctype>
#include <cmath>

using namespace Eigen;

// Function to extract text from output file, excluding [BLANK_AUDIO]
std::string extractText(const std::string& filePath) {
    std::ifstream file(filePath);
    std::string line, content;

    if (file.is_open()) {
        while (std::getline(file, line)) {
            if (line.find("[BLANK_AUDIO]") == std::string::npos) {
                content += line + "\n";  // Add valid line to content
            }
        }
        file.close();
    } else {
        std::cerr << "Unable to open the file: " << filePath << std::endl;
    }

    return content;
}

// Function to calculate term frequency for a document
std::map<std::string, double> term_frequency(const std::vector<std::string>& tokens) {
    std::map<std::string, double> tf;
    double total_terms = tokens.size();

    for (const std::string& token : tokens) {
        tf[token] += 1.0;
    }

    for (auto& pair : tf) {
        pair.second /= total_terms; // Normalize by total terms
    }

    return tf;
}

// Function to calculate inverse document frequency for a vocabulary
std::map<std::string, double> inverse_document_frequency(const std::map<std::string, int>& vocab, const std::map<std::string, std::vector<std::string>>& documents) {
    std::map<std::string, double> idf;
    int N = documents.size(); // Total number of documents

    for (const auto& [term, index] : vocab) {
        int df = 0; // Document frequency
        for (const auto& doc : documents) {
            if (std::find(doc.second.begin(), doc.second.end(), term) != doc.second.end()) {
                df++;
            }
        }
        idf[term] = std::log(static_cast<double>(N) / (1 + df)); // Avoid division by zero
    }

    return idf;
}

// Function to compute TF-IDF for a document
VectorXd compute_tfidf_vector(const std::vector<std::string>& tokens, const std::map<std::string, double>& idf, const std::map<std::string, int>& vocab) {
    std::map<std::string, double> tf = term_frequency(tokens);
    VectorXd tfidf_vector = VectorXd::Zero(vocab.size());

    for (const auto& term : vocab) {
        if (tf.find(term.first) != tf.end()) {
            tfidf_vector(term.second) = tf[term.first] * idf.at(term.first);
        }
    }

    return tfidf_vector;
}


// Function to convert a string to lowercase
std::string to_lowercase(const std::string& str) {
    std::string result = str;
    std::transform(result.begin(), result.end(), result.begin(), ::tolower);
    return result;
}

// Function to tokenize a sentence
std::vector<std::string> tokenize(const std::string& text) {
    std::vector<std::string> tokens;
    std::string token;
    for (char ch : text) {
        if (isspace(ch)) {
            if (!token.empty()) tokens.push_back(token);
            token.clear();
        } else {
            token += ch;
        }
    }
    if (!token.empty()) tokens.push_back(token);
    return tokens;
}

// Function to calculate cosine similarity between two vectors
double cosine_similarity(const VectorXd& vec1, const VectorXd& vec2) {
    double dot_product = vec1.dot(vec2);
    double norm_vec1 = vec1.norm();
    double norm_vec2 = vec2.norm();
    return (norm_vec1 == 0 || norm_vec2 == 0) ? 0.0 : (dot_product / (norm_vec1 * norm_vec2));
}

// Function to convert a sentence into a frequency vector
VectorXd sentence_to_vector(const std::vector<std::string>& tokens, const std::map<std::string, int>& vocab) {
    VectorXd vec = VectorXd::Zero(vocab.size());
    for (const std::string& token : tokens) {
        if (vocab.find(token) != vocab.end()) {
            vec(vocab.at(token)) += 1;
        }
    }
    return vec;
}

// Function to load questions and responses from a text file
std::map<std::string, std::string> load_responses(const std::string& filename, std::vector<std::string>& questions) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Could not open the text file.\n";
        exit(EXIT_FAILURE);
    }

    std::map<std::string, std::string> question_response_map;
    std::string question, response;

    while (std::getline(file, question) && std::getline(file, response)) {
        question_response_map[question] = response;
        questions.push_back(question);  // Store the question for later use
    }

    file.close();
    return question_response_map;
}

// Update the find_best_response function to use TF-IDF
std::pair<std::string, double> find_best_response_with_tfidf(const std::string& input, const std::map<std::string, std::string>& question_response_map) {
    std::vector<std::string> input_tokens = tokenize(input);

    // Build vocabulary
    std::map<std::string, int> vocab;
    std::map<std::string, std::vector<std::string>> documents;
    int index = 0;

    // Populate the vocabulary and documents
    for (const auto& entry : question_response_map) {
        std::vector<std::string> response_tokens = tokenize(entry.second);
        documents[entry.first] = response_tokens; // Store responses as documents
        for (const std::string& token : response_tokens) {
            if (vocab.find(token) == vocab.end()) {
                vocab[token] = index++;
            }
        }
    }

    // Calculate IDF for the vocabulary
    auto idf = inverse_document_frequency(vocab, documents);

    // Compute TF-IDF for input and responses
    VectorXd input_vector = compute_tfidf_vector(input_tokens, idf, vocab);

    double max_similarity = -1;
    std::string best_response;

    // Compare with all responses using TF-IDF
    for (const auto& entry : question_response_map) {
        std::vector<std::string> response_tokens = tokenize(entry.second);
        VectorXd response_vector = compute_tfidf_vector(response_tokens, idf, vocab);
        double similarity = cosine_similarity(input_vector, response_vector);

        if (similarity > max_similarity) {
            max_similarity = similarity;
            best_response = entry.second;
        }
    }

    return {best_response, max_similarity};  // Return the best response and its similarity score
}

// Function to calculate keyword match count
int keyword_match_count(const std::string& response, const std::vector<std::string>& keywords) {
    int match_count = 0;
    std::string response_copy = to_lowercase(response);
    
    for (const std::string& keyword : keywords) {
        if (response_copy.find(to_lowercase(keyword)) != std::string::npos) {
            match_count++;
        }
    }
    
    return match_count;
}

// Function to evaluate the response using keyword matching and cosine similarity
double evaluate_response(const std::string& response, const std::string& ideal_answer, const std::vector<std::string>& keywords) {
    int matches = keyword_match_count(response, keywords);
    double keyword_score = static_cast<double>(matches) / keywords.size();  // Normalize score

    // Calculate cosine similarity to ideal answer
    std::vector<std::string> ideal_answer_tokens = tokenize(ideal_answer);
    std::vector<std::string> response_tokens = tokenize(response);

    std::map<std::string, int> vocab;
    int index = 0;

    // Build vocabulary
    for (const auto& token : ideal_answer_tokens) {
        if (vocab.find(token) == vocab.end()) {
            vocab[token] = index++;
        }
    }
    for (const auto& token : response_tokens) {
        if (vocab.find(token) == vocab.end()) {
            vocab[token] = index++;
        }
    }

    VectorXd ideal_answer_vector = sentence_to_vector(ideal_answer_tokens, vocab);
    VectorXd response_vector = sentence_to_vector(response_tokens, vocab);
    
    double cosine_sim_score = cosine_similarity(response_vector, ideal_answer_vector);

    // Combine scores for a final rating
    double final_rating = (keyword_score + cosine_sim_score) / 2 * 10;  // Scale to 1-10 rating
    return final_rating;
}

int main() {
    // Paths to the batch files and output text file
    const char* recordBatchFilePath = "C:\\CollegeStuff\\TY\\AI\\CP\\run_record_audio.bat";
    const char* whisperBatchFilePath = "C:\\CollegeStuff\\TY\\AI\\CP\\run_whisper.bat";
    const std::string outputFilePath = "C:\\CollegeStuff\\TY\\AI\\CP\\output.wav.txt";

    // Load the question-response map and questions
    std::vector<std::string> questions;
    std::map<std::string, std::string> question_response_map = load_responses("nlp.txt", questions);

    // Display the first question from the loaded questions
    if (!questions.empty()) {
        std::cout << "Question: " << questions[0] << std::endl;  // Display the first question
    } else {
        std::cerr << "No questions found in the file." << std::endl;
        return EXIT_FAILURE;
    }

    // Execute the recording batch file
    std::cout << "Executing recording batch file..." << std::endl;
    int recordResult = system(recordBatchFilePath);

    // Check the result of the recording execution
    if (recordResult == 0) {
        std::cout << "Recording batch file executed successfully." << std::endl;

        // Execute the whisper batch file
        std::cout << "Executing whisper batch file..." << std::endl;
        int whisperResult = system(whisperBatchFilePath);

        // Check the result of the whisper execution
        if (whisperResult == 0) {
            std::cout << "Whisper batch file executed successfully." << std::endl;

            // Extract and process the text from the output file
            std::string extracted_text = extractText(outputFilePath);
            std::cout << "Extracted Text:\n" << extracted_text << std::endl;

            // Find and display the best response based on extracted text
            auto [best_response, similarity_score] = find_best_response_with_tfidf(extracted_text, question_response_map);
            std::cout << "Best Response: " << best_response << std::endl;
            std::cout << "Cosine Similarity Score: " << similarity_score << std::endl;  // Display the score

            // Define keywords for evaluation
            std::vector<std::string> keywords = {"important", "knowledge", "learning"};

            // Evaluate the extracted response against an ideal answer
            const std::string ideal_answer = "It is important to always value knowledge and stay committed to learning.";
            double final_rating = evaluate_response(extracted_text, ideal_answer, keywords);
            // std::cout << "Response Evaluation Rating: " << final_rating << std::endl;  // Display the final rating
        } else {
            std::cerr << "Failed to execute whisper batch file. Error code: " << whisperResult << std::endl;
        }
    } else {
        std::cerr << "Failed to execute recording batch file. Error code: " << recordResult << std::endl;
    }

    return 0;
}